# 映客直播
## new 和 不是 new出来的变量\对象有什么区别？
- 基本数据类型不需要new而直接定义，而引用数据类型在定义实例时需要new实例对象。
- java里对象传递的时候，传递的都是引用（也就是对象的地址）
- new出来的变量或者对象是在jcm堆中开辟了一块地址，不是new的只是声明了一个对象的引用，并没有在jvm中开辟内存放入对象。

## 配置中心做了什么？
- 当系统从一个单体应用，被拆分称分布式系统上的一个个服务节点，其配置文件也是需要迁移的，这样的话，随着需求不断增加，配置会越来越多，稍不注意出错，
  就得修改配置重新打包部署。
- 配置中心顾名思义配置中性化，将配置从应用中抽取出来，统一管理，优雅的解决了配置的动态变更、权限管理、持久化、运维成本等问题。

## 配置中心如何保证一致性和热部署
- 基于消息总线的配置中心架构需要依赖外部MQ组件，比如 Kakfa、pulsar实现远程事件变更通知，客户端可以实时配置变更基于Git Hook功能实现

## Spring中用了单例Bean，如何保证Bean字段时的并发安全？
- Spring单例模式是在内存中只实例化一个类对象。确保某个类只有一个实例，而且自行实例化会向整个系统提供这个实例
- 当多个用户同时请求一个接口服务的时候，容器会给每一个请求分配一个线程，这时候多个线程会并发执行该请求所对应的业务逻辑。如果该逻辑涉及到对该单例状态
  （成员变量）的改变，就会有线程安全的问题。
- Spring使用ThreadLocal来解决线程安全问题，每个线程去执行业务代码的时候，都会去内存申请临时变量，这样就不会涉及变量并发访问冲突的问题。
- 一般的 Web 应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回
  响应所经过的所有程序调用都同属于一个线程。

## 建立一个socket连接要经过哪些步骤？
- 在服务端建立一个ServerSocket,绑定相应的端口，并且在指定的端口进行侦听，等待客户端的连接。
- 当客户端创建连接Socket并且向服务端发送请求。
- 服务器收到请求，并且接收客户端的请求信息，一旦接收到客户端的连接请求后，会创建一个链接socket，用来与客户端的socket进行通信
- 关闭socket

## 常见的HTTP状态码
- 2开头，请求成功 eg：200
- 3开头，表示要完成请求，需要进一步操作，eg：302
- 4开头，表示请求出错，eg：404
- 5开头，表示服务器内部错误，eg：500

### HTTP 301和302的区别
- 301：旧的地址不可用（永久移除），重定向到另一个网址，并且将该网址保存为新网址
- 302：旧地址可用，跳转新地址

### HTTP 500和504区别
- 1.后端脚本出现错误 2.高并发时候，因为系统资源限制，而不能打开过多文件
- 没有到达网关，eg：Nginx

### HTTP和HTTPS区别
- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### 快速排序算法
```java
public class Test{
    public void sort(int[] array){
        arraySort(array,0,array.length - 1);
    }
    
    private void arraySort(int[] src, int begin, int end){
        if (begin < end ) {
            int key = src[begin];
            int i = begin;
            int j = end;
            while (i < j) {
              while (i < j && src[j] > key) {
                j--;
              }
              if (i < j) {
                src[i] = src[j];
                i++;
              }
              while (i < j && src[i] < key) {
                i++;
              }
              if (i < j) {
                src[j] = src[i];
                j--;
              }
            }
            src[i] = key;
            arraySort(src, begin, i - 1);
            arraySort(src, i + 1, end);
        }
    }

  public static void main(String[] args) {
    int[] arrays = new int[]{47,29,71,99,78,19,24,47};
    
  }
}
```

### 快排的实现
- 首先我们需要在数列中选择一个基准数，我们一般会选择中间的一个数或者头尾的数，这里直接选择第 1 个数 47 作为基准数，接着把比 47 小的数字移动到左边，
  把比 47 大的数字移动到右边，对于相等的数字不做移动。所以实际上我们需要找到中间的某个位置 k，这样 k 左边的值全部比 k 上的值小，k 右边的值全部比
  k 上的值大。
  
- 首先从数列的右边开始往左边找，我们设这个下标为 j，也就是进行减减操作（j--），找到第 1 个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，
  设这个下标为 i，然后执行加加操作（i++），找到第 1 个比基准数大的值，让它与基准值交换；然后继续寻找，直到 i 与 j 相遇时结束，最后基准值所在的位
  置即 k 的位置，也就是说 k 左边的值均比 k 上的值小，而 k 右边的值都比 k 上的值大。
