# 状态化流处理概述
## 流处理基础
### Dataflow编程概述
#### Dataflow图
有向图：
- Dataflow程序描述了数据如何在不同操作之间流动。Dataflow程序通常表示为有向图。图中的顶点称为算子，表示计算；而边表示数据依赖关系。

算子是Dataflow程序的基本功能单元，它们从输入获取数据，对其进行计算，然后产生数据并发往输出以供后续处理。没有输入端的算子称为 数据源，没有输出端的算
子称为 数据汇。一个Dataflow图至少要有一个数据源和一个数据汇。

逻辑图：
- 表达高层视角下的计算逻辑，为了执行Dataflow程序，需要将逻辑图转化为物理Dataflow图，后者会指定程序的执行细节。
- 在逻辑Dataflow中，顶点代表算子；在物理Dataflow图中，顶点代表任务，"抽取主题标签和"计数"算子都包含两个并行算子任务，每个任务负责计算一部分输入
  数据。
  
### 数据并行和任务并行
Dataflow图的并行性可以通过多种方式加以利用。首先，你可以将输入数据分组，让同一操作的多个任务并行执行在不同数据子集中，这种并行称为数据并行
（data parallelism），让不同算子的任务（基于相同或不同的数据）并行计算，这种并行称为任务并行（task parallelism）。

### 数据交换策略
数据交换策略定义了如何将数据项分配给物理Dataflow图中的不同任务。
- 转发策略（forward strategy）：在发送端任务和接收端任务之间一对一地进行数据传输，如果两端任务运行在同一物理机器上，该交换策略可以避免网络通信。
- 广播策略（broadcast strategy）：会把每个数据项发往下游算子的全部并行任务。该策略会把数据复制多份且涉及网络通信，因此代价十分昂贵。
- 基于键值的策略（key-based strategy）：根据某一键值属性对数据分区，并保证键值相同的数据项会交由同一任务处理，
- 随机策略（random strategy）：会把数据均匀分配至算子的所有任务，以实现计算任务的负载均衡

### 并行流处理
数据流：数据流是一个可能无限的事件序列

#### 延迟和吞吐
- 延迟：延迟表示处理一个事件所需的时间。本质上，它是从接收事件到在输出中观察到事件处理效果的时间间隔。
- 在真正的流模型中，事件一到达系统就可以进行处理，延迟会更加真实地反映出每个事件都要经历的实际处理工作。

#### 吞吐
- 吞吐是用来衡量系统处理能力（处理速率）的指标，它告诉我们系统每单位时间可以处理多少时间。
- 吞吐的衡量方式是计算每个单位时间的事件或操作数，但要注意，处理速率取决于数据到来速率，因此吞吐低不一定意味着性能差。
- 背压：事实上，一旦事件到达速率过高致使系统没有空闲资源，系统就会被迫开始缓冲事件。如果系统持续以力不能及的高速率接收数据，那么缓冲区可能会用尽，继而可能
导致数据丢失。
  
### 数据流上的操作
流处理引擎通常会提供一系列内置操作来实现数据流的获取、转换、以及输出。这些算子可以组合生成Dataflow处理图，从而实现流式应用所需的逻辑。

这些操作既可以是无状态（stateless）的，也可以是有状态的（stateful），无状态的操作不会维持内部状态，即处理事件时无需依赖已处理过的事件，也不保存
历史数据。由于事件处理互不影响且与事件的到来时间无关，无状态的操作很容易并行化

#### 数据接入和数据输出
- 数据接入和数据输出操作允许流处理引擎和外部系统进行通信。数据接入操作是从外部数据源获取原始数据并将其转换成适合后续处理的格式。实现数据接入操作逻辑
的算子称为数据源。
  
#### 转换操作
- 转换操作是一类"只过一次"的操作，它们会分别处理每个事件，这些操作逐个读取事件，对其应用的某些转换并产生一条新的输出流，转换逻辑可以是算子内置的，
也可以是由用户自定义函数提供的。
  
#### 滚动聚合
- 滚动聚合会根据每个到来的事件持续更新结果，聚合操作都是有状态的，它们通过将新到来的事件合并到已有状态来生成更新后的聚合值。
- 为了更有效地合并事件和当前状态并生成耽搁结果，聚合函数必须满足可结合（associative）及可交换（commutative）的条件，否则算子就需要存储整个流
的历史记录，
  
#### 窗口操作
- 转换操作和滚动聚合每处理一个事件来产生输出并（可能）更新状态，然而，有些操作必须收集并缓存记录才能计算结果，
- 窗口操作会持续创建一些称为"桶"的有限事件集合，并允许我们基于这些有限集进行计算
- 窗口的行为是由一系列策略定义的，这些窗口策略决定了什么时间创建桶，事件如何分配到桶中以及桶内数据什么时间参与运算

#### 滚动窗口
- 将时间分配到长度固定且互不重叠的桶中。在窗口边界通过后，所有事件会发送给计算函数进行处理，基于数据的（count-based）滚动窗口定义了再触发计算前需
要集齐多少条事件。
  
  
#### 滑动窗口
- 将事件分配到大小固定且允许相互重叠的桶中，这意味着每个事件可能会同时属于多桶
- 通过指定长度和滑动间隔来定义滑动窗口。滑动间隔决定每隔多久生成一个新的桶

#### 会话窗口
- 在一些常见的真实场景中非常有用，比如 需要把事件按照用户的同一活动或会话来源进行分组。
- 会话由发生在相邻时间内的一系列事件外加一段非活动时间组成。

### 窗口操作中与流处理中两个核心概念密切相关：
- 时间语义（time semantics）
- 状态管理（state management）

### 时间语义
流失应用可以使用两个不同概念的时间，即处理时间（process time）和事件时间（event time）
#### 处理时间
- 处理时间是当前流处理算子所在机器上的本地时钟时间。基于处理时间的窗口会包含那些恰好在一段时间内到达窗口算子的事件，这里的时间段是按照机器时间测量的。

#### 事件时间
- 事件时间是数据流中事件实际发生的时间，它以附加在数据流中事件的时间戳为依据

#### 水位线
- 水位线是一个全局进度指标，表示确信不会再有延迟事件到来的某个时间点。
- 水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。算子一旦收到某个水位线，就相当于接到信号：某个特定时间区间的时间戳已经到齐，可以触发窗口
计算或对接收的数据进行排序了。
  
- 水位线允许我们在结果的准确性和延迟之间做出取舍。激进的水位线策略保证了低延迟，但随之而来的是低可信度

#### 处理时间与事件时间
- 虽然处理时间提供了很低的延迟，但它的结果依赖处理速度，具有不确定性。事件时间则与之相反，能保证结果的准确性，并允许处理延迟甚至无序的事件。

#### 状态和一致性模型
状态管理
- 系统需要高效地管理状态并保证它们不受并发更新的影响

状态划分
- 由于结果需要同时依赖状态和到来的事件，所以状态并行化会变得异常复杂。

状态恢复
- 有状态算子需要保证状态可以恢复，并且即时出现故障也要保证结果正确

#### 任务故障
什么是任务故障？
对于每个输入流中的每个事件，任务都需要执行以下步骤：
- 接收事件并将他们存在本地缓冲区
- 选择性地更新内部状态
- 产生输出记录

### 结果保障
- 当提到 结果保障 时，我们指的是流处理引擎内部状态的一致性，保证应用状态的一致性和保证输出的一致性并不是一回事儿

#### 至多一次
任务发生故障时最简单的措施就是既不恢复丢失的状态，也不重放丢失的状态。

#### 至少一次
- 对大多数现实应用而言，用户期望的是不丢事件，这类保障称为至少一次
- 为了确保至少一次结果语义的正确性，需要想办法从源头或缓冲区中重放时间。持久化事件日志会将所有事件写入永久存储，这样在任务故障时就可以重放他们。
- 实现该功能的另一个方法就是记录确认（record acknowledgments），该方法会将所有事件存在缓冲区中，直到处理管道中所有任务都确认某个事件已经处理完
  毕才会将事件丢弃
  
#### 精确一次
- 表示不但没有事件丢失，而且每个事件对于内部状态的更新都只有一次。
- 提供精确一次保障是以至少一次保障为前提，因此同样需要数据重放机制，
- Flink采取了轻量级检查点机制来实现精确一次结果保障

#### 端对端精确一次
端对端的保障指的是在整个数据处理管道上结果都是正确的，在每个组件都提供自身的保障情况下，整个处理管道端对端的保障会受制于保障最弱的那个组件。










