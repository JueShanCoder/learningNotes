# 深入理解Java虚拟机 第二章
# Java内存区域与内存溢出异常
## 运行时数据区域
- Java 虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。

### 程序计数器
- 程序计算器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

> 线程私有：每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

- 如果一个线程正在执行的是一个Java的方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址

- 如果正在执行的是Native方法，这个计数器值则为空（Undefined）

### Java虚拟机栈
- Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期和线程相同。

- 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链表、方法出口等信息。
- 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。

- 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double），其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余数据类型只占用1个。

- StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
- OutOfMemoryError异常：如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError异常。

### 本地方法栈
- 虚拟机栈为虚拟机提供Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

### Java堆
- Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

- 从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代 和 老年代，再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

### 方法区 
- 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 运行时常量池
- 运行时常量池（Runtime Constant Pool）是方法区的一部分。

### 直接内存
- 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分。
- 在JDK 1.4中新加入NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为
这块内存的引用进行操作。

### 对象的创建
- 虚拟机遇到一条new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须执行相应的类加载过程。
- 在类加载通过后，接下来虚拟机为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
- 指针碰撞： 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离。
- 空闲列表： 假设Java堆中内存并不是绝对规整的，已使用的内存和空闲的内存相互交错，此时，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表的记录。

- 使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞。
- 使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。

- 并发修改指针问题： 一种是对分配内存空间的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为
  本地线程分配缓冲（Thread Local Allocation Buffer TLAB），哪个线程要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。
  

