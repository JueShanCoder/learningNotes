# JVM
## G1垃圾收集器
G1和CMS比较，有一些不通点让G1成为一个更好的解决方案，一个不通点是G1是一个压缩收集器，
G1收集器充分地压缩空间以完全避免为分配空间使用细粒度的空闲列表，而不是依赖区块。
同时G1收集器相比CMS收集器而言，提供更可预言的垃圾手机暂停时间，允许用户指定想要暂停时间指标。

### G1收集器操作概览
旧的垃圾收集器（串行的：serial，并行的：parallel，并发标记清除：CMS）都把堆结构化为三个部分：年轻代、年老代和固定大小的永久代。 
![](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/HeapStructure.png)

G1收集器应用了一个不同的方法
![](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png)

堆空间被分割成一些相同大小的堆区域，每一个都是连续范围的虚拟内存。特定的区域集合像旧的收集器一样被指派为相同的角色（eden、survivor、old），但是
他们没有一个固定大小。这在内存使用上提供了更强大的灵活性。

当执行垃圾收集时，G1收集器以CMS收集器类似的方式操作。G1收集器执行一个全局的并发标记阶段来决定堆中的对象的活跃度。之后标记阶段就完成了。G1收集器知道
哪个区域基本上是空的。它首先会收集那么产出大量空闲空间的区域。G1收集器集中它的收集和压缩活动在堆里的那些可完全被回收的区域，那就是垃圾。G1收集器使用
一个暂停预言的模式去达到一个用户定义的暂停时间指标，基于用户指定的暂停时间指标去选择收集区域的数量。

被G1收集器鉴定为可以回收的区域就是垃圾，使用抽空的方式收集。G1收集器从堆空间的一个或多个区域里复制对象到堆空间的一个单独的区域内，这个过程中同时压缩
和释放内存。这个抽空过程在多处理上以并行的方式运行，以减小暂停时间和增加吞吐量。因此，每一次垃圾收集G1收集器连续不断地去减少碎片，在用户指定的暂停时
间内工作。这超越了以往方法的能力。并发标记-清除（CMS，Concurrent Mark Sweep）垃圾收集器不做压缩操作。并行年老代（ParallelOld）垃圾收集只进行
整个堆的压缩，会导致相当大的暂停时间。

> Tips 
> G1收集器不是实时的收集器非常重要。它在很大程度上符合用户设定的暂停时间指标但是并不绝对符合。基于前面垃圾收集的数据来看，G1收集器会估算在用户指定的
> 时间指标能收集多少区域。因此，收集器有一个合理的精确的收集这些区域的代价模型，它使用这个模型决定在用户指定的暂停时间内收集哪些、多少个区域。
> 
> G1收集器同时有并发（和应用线程一起运行，比如：提炼、标记、清理）和并行（多线程，比如：STW）两个阶段，全量垃圾回收仍然是单线程的，但是如果调优的适
> 当你的应用应该会避免全量垃圾回收。

### G1回收期足迹
