#  Java并发编程

## Synchronized
### Synchronized同步锁
- synchronized 可以把任意一个非NULL的对象当做锁，它属于独占悲观锁，同时属于可重入锁

### Synchronized作用范围
- 作用于方法时，锁住的是对象的实例（this）
- 当作用于静态方法时，锁住的是class实例，又因为Class的相关数据存储在metaspace中，metaspace是全局共享的，所以静态方法锁 = 全局类锁
- synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块，有多个队列，当多个线程一起访问某个对象监听器时候，对象监视器会将这些线程存
储在不同的容器中。
  
### Synchronized核心组件
- WaitSet：哪些调用wait方法被阻塞的线程被放置在这里；
- ContentList：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
- EntryList：Contention List中那些有资格称为候选资源的线程被移动到EntryList中
- OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck
- Owner：当前已经获取到锁资源的线程被称为Owner
- !Owner：当前释放锁的线程

### Synchronized实现
![](https://box.kancloud.cn/d8a98f76177f4347faca253d8a61da1f_570x252.jpg)
- JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（ OnDeck ），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾
  部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。
- Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先
  进去的那个线程）。
- Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck ，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系
  统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。
- OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 
  队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。
- 处于 ContentionList 、 EntryList 、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 
  内核函数实现的）。
- Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，
  这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。
- 每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁
  是通过一个标记位来判断的
- synchronized是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。

### synchronized用法
#### 同步一个代码块
- 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。
```java
public void func() {
    synchronized (this) {
        // ...
    }
}
```

#### 同步一个方法
- 同样也是同步一个对象
```java
public synchronized void func () {
    // ...
}
```

#### 同步一个类
- 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。
```java
public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
```

#### 同步一个静态方法
- 非静态同步函数的锁是：this
- 静态的同步函数锁是：字节码对象
```java
public synchronized static void fun() {
    // ...
}
```

## ReentrantLock
ReentrantLock继承接口Lock并实现了接口中定义的方案，是一种可重入锁，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮
询锁请求、定时锁等，避免多线程死锁的方法。
### Lock接口的主要方法





